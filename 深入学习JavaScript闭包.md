关于本文：

[原文地址]( https://medium.freecodecamp.com/lets-learn-javascript-closures-66feb44f6a44?gi=e0c9ec232139#.23peoxdhn)  [翻译地址](**********)   译者：野草 

本文发表于前端早读课[【第8****期】](***********)


闭包（closure）是JavaScript中最基本的概念，也是每个前端工程师都应该彻底掌握的概念。网上有很多教程，通俗易懂地解释了闭包的概念，却鲜有深入探讨闭包背后的机制和原理。

笔者在工作中深有感悟，彻底地理解和掌握某个知识点的本质，会让你在工作中游刃有余。因此经过笔者深入地学习调研之后，本文全面而透彻地分析闭包的运行方式，以及运行背后的机制。

希望读完本文之后，你能有所收获，并能在以后的工作中利用好闭包，发挥它最大的作用。

## 闭包是什么

闭包是JavaScript（包括其他绝大多数语言）中非常强大的特性，[MDN]( https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)上是这样定义的：

> 闭包是指那些能够访问自由变量（既不是本地定义而不作为参数的那些变量）的函数。换句话说，这些函数可以“记住”它被创建时候的环境。

我们来看些例子。 

### Example 1： 

	function numberGenerator() {
	  // 闭包内的局部自由变量
	  var num = 1;
	  function checkNumber() { 
	    console.log(num);
	  }
	  num++;
	  return checkNumber;
	}
	
	var number = numberGenerator();
	number(); // 2

本例中，函数`numberGenerator`创建了局部自由变量`num`，以及打印`num`的函数` checkNumber `。` checkNumber `没有自己的局部变量，却可以访问`numberGenerator`内的变量，这就是闭包在起作用。因此，即使在`numberGenerator`执行完毕之后，` checkNumber `仍然能成功访问`num`，并打印出来。

### Example 2：

我们用本例来证明，闭包能访问外部封闭函数内定义的所有变量。
	
	function sayHello() {
	  var say = function() { console.log(hello); }
	  // 闭包内的局部自由变量
	  var hello = 'Hello, world!';
	  return say;
	}
	var sayHelloClosure = sayHello(); 
	sayHelloClosure(); // ‘Hello, world!’

我们发现，变量`hello`是在匿名函数之后定义，但它仍能被匿名函数访问到。因为程序在编译的时候，`hello`已经在函数作用域中定义，程序执行的时候自然就能访问到了。稍后我会解释作用域是什么，没看懂可以暂时跳过。

### 闭包总揽

上述例子从比较高的层次去阐释了闭包的概念，归纳为一句话：“定义在封闭函数（enclosing function）中的变量，即使在该封闭函数执行完之后，仍然能被访问到”。显然，这不合常理的现象背后肯定有些不寻常的东西。

为了彻底搞清楚闭包，我们需要“掘地三尺”，深挖与闭包相关的概念。准备好了吗？那我们就从最核心的“执行上下文”（Execution Context，函数运行的环境）开始说起吧。

## 执行上下文 

执行上下文是ECMAScript标准中定义的一个抽象概念，用来记录代码运行的环境。它可以是代码最开始执行的全局上下文，也可以是执行进入某个函数体内的上下文。

图片。。。。。。。。。。。。

需要注意的是，程序至始至终只能进入某一个执行上下文。这也是为什么说JavaScript是单线程的原因，即每次只能有一个命令在执行。通常，浏览器用“栈”来维护执行上下文。“栈”遵循“后入先出（Last In First Out）”的原则，也就是说最后进栈的最先出栈（因为我们只能操作栈顶）。当前起作用的执行上下文位于栈顶，当它内部的代码执行完毕之后出栈 ，然后将下一个元素作为当前的上下文。

另外，程序并不需要执行完当前的执行上下文中的所有代码，才能进入另一个执行上下文。经常会有当前的上下文A执行到一半暂停，又进行了另一个上下文B的情况。当程序在上下文B中彻底结束之后，又回到上下文A中，从它暂停的地方重新继续执行。每次一个上下文被另外一个上下文所替代时，这个新的上下文就入栈成为栈顶，即当前的上下文。

图片。。。。。。。。

举个比较实际的例子。

	var x = 10;
	function foo(a) {
	  var b = 20;
	
	  function bar(c) {
	    var d = 30;
	    return boop(x + a + b + c + d);
	  }
	
	  function boop(e) {
	    return e * -1;
	  }
	
	  return bar;
	}
	
	var moar = foo(5); // 闭包 
	/* moar函数实际上是foo函数执行之后返回的bar函数。bar函数中调用boop，此时bar函数执行暂停，boop函数进入了执行，而boop对应的执行上下文就成了执行上下文栈中的栈顶。  */
	moar(15); 

图片。。。。。。。。。。

当boop函数执行完毕，boop函数的执行上下文出栈，bar函数又继续执行。

图片。。。。。。。。。

当有一堆执行上下文，一个接着一个地运行，有些执行到一半暂停后来又继续，这里需要回来继续执行的时候能记住当前的状态。事实上，ECMAScript中已经做出了规定，每个执行上下文都有用来追踪执行过程的各种状态组件。它们包括以下几个：

+ 代码执行状态（Code evaluation state）: 在当前执行上下文中用来记录代码执行，暂停，重新执行的状态
+ 函数（Function）：当前上下文正在执行的函数体（如果当前上下文是脚本或者模块，函数则为null）
+ 范畴（Realm）：内部对象集合，全局运行环境及其作用于下的所有代码，其他相关的状态、资源
+ 词法环境（Lexical Environment）：用来解决当前上下文中的标识符引用问题
+ 变量环境（Variable Environment）：词法环境下与环境记录（EnvironmentRecord）紧密联系的变量声明（VariableStatements）

是不是都看晕了？（译者也有译晕了！）没关系，这里我们只关心词法环境，它明确地解释了标识符引用的问题。你可以认为标识符就是变量。我们最初的目的是为了搞清楚函数在返回之后内部的变量为何还能被访问到，词法环境正是我们需要深挖的东西。

Note： 严格上来说，环境变量和词法变量都与闭包的实现有关系。但为简单起见，我们把它们合并称为“环境”。若想详细了解二者的区别，请看Dr. Alex Rauschmayer写的[文章]( http://www.2ality.com/2011/04/ecmascript-5-spec-lexicalenvironment.html)。

## 词法环境

[ES6]( http://www.ecma-international.org/ecma-262/6.0/#sec-lexical-environments)中明确定义：词法环境是用来定义标识符和具体变量之间的关系以及词法嵌套结构内的函数，它包括环境记录和指向外部词法环境的引用（有可能指向null）。通常词法环境跟一些具体语法结构有关，比如函数声明（FunctionDeclaration），块语句声明（BlockStatement），Try/Catch语句，这些代码在执行的时候又会生成一个新的词法环境。

我们来仔细解读一下。

+ 用来定义标识符的值：词法环境的目的就是管理代码中的数据。也就是说，它给标识符赋值，让标识符变得有意义。比如，代码段“console.log(x/10)”，如果x没有具体值，x是没有意义的，这段代码也没有意义。词法环境通过环境记录将标识符和具体的值联系在一起（见下一点）。

+ 词法环境包含环境记录：环境记录完美地记录了词法环境中所有标识符和具体值之间的联系，并且每个词法环境都有自己的环境记录。

+ 词法嵌套结构：内部环境引用包含它的外部环境，外部环境还可以有自己的外部环境。因此，一个环境可以作为多个内部环境的外部环境。全局环境是唯一一个没有外部环境的环境。说起来有点绕，我们用洋葱来做个比喻：全局环境是洋葱最外面的一层，每一层都嵌套在里面，一层又一层，就像我们的词法环境。


洋葱图片。。。。。。。。。。。。。。。。。

我们用伪代码来抽象一下：

	LexicalEnvironment = {
	  EnvironmentRecord: {
	  // 标识符的赋值操作
	  },
    //外部环境的引用 
	  outer: < >
	};

+ 这些代码在执行的时候又会生成一个新的词法环境：每当外部封闭函数执行时，就会产生一个新的词法环境。这很重要，最后会回来讲这点。（函数不是唯一创建词法环境的方式，块语句，catch语句都可以。还是为了简单，我们只关注由函数创建的环境。）

总而言已，每个执行上下文都对应一个词法环境。这个词法环境中记录着变量和它对应的值，还有指向外部环境的引用。它可以是全局环境，模块环境（包括模块之间的引用关系），或函数环境（由函数调用而创建的环境）。

## 作用域链（Scope Chain）

基于上述定义，我们已经知道一个环境可以访问它的外部环境，它的外部环境又可以继续访问它外部的外部环境，以此类推。每个环境能访问到的标识符集合，我们称之为“作用域”。我们将作用域一层一层嵌套，形成了“作用域链”。

我们来看嵌套结构的例子。

  var x = 10;
	
	function foo() {
	  var y = 20; // free variable
	  function bar() {
	    var z = 15; // free variable
	    return x + y + z;
	  }
	  return bar;
	}

如上所示，bar函数嵌套在foo函数中。我们用下面这张图来更直观地感受函数的嵌套关系。

函数嵌套 图片。。。。。。。。。。。。。。。。

等下我们还会回到这个例子。

这个作用域链，或者说函数的环境链，在函数创建的时候就保存起来了。也就是说，它是由源代码的位置静态定义的，（这就是我们熟悉的词法作用域Lexical Scope）

我们先快速地了解一下，“动态作用域”（Dynamic Scope）与“静态作用域”（Static Scope）的区别，我们就能知道为什么静态作用域是产生闭包的一个必要条件了。
