
关于本文：

[原文地址]( https://bitsofco.de/understanding-the-critical-rendering-path/)   [翻译地址]( https://github.com/fezaoduke/TranslationInstitute/blob/master/%E7%90%86%E8%A7%A3%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84.md) 译者：野草

本文发表于前端早读课[【第8**期】](*****)


有一个很经典的面试题：当你在浏览器输入一个网址并按下回车之后发生了什么？本文就来说说当浏览器从服务器获取了HTML文件之后经历哪些过程。事实上，从获取到HTML文件在像素点显示在浏览器上的确经历了好些过程。这其中浏览器需要经历的步骤（直到首屏渲染出来）称之为“关键渲染路径”(Critial Rendering Path)。

理解关键渲染路径是提高页面性能的关键所在。总体来说，关键渲染路径分为六步。

+ 创建DOM树
+ 创建CSSOM树
+ 执行JavaScript
+ 生成渲染树
+ 回流/创建布局
+ 重绘

![](https://bitsofco.de/content/images/2017/01/CRP-Sequence-Copy.png)

## 创建DOM树

DOM(文档对象模型)树是HTML页面完全解析后的对象表示。从根元素`<html>`开始，页面上每个元素或者文本都会相应地创建一个节点。每个节点都包含了这个元素的所有属性，并且嵌套在元素内的元素会被解析成外层元素对应的节点的子节点。比如，元素`<a>`标签对应的节点会有一个属性为`href`对应的子节点。

比如下面这个简单的HTML结构：

```
<html>  
<head>  
  <title>Understanding the Critical Rendering Path</title>
  <link rel="stylesheet" href="style.css">
</head>  
<body>  
  <header>
      <h1>Understanding the Critical Rendering Path</h1>
  </header>
  <main>
      <h2>Introduction</h2>
      <p>Lorem ipsum dolor sit amet</p>
  </main>
  <footer>
      <small>Copyright 2017</small>
  </footer>
</body>  
</html>  
```

它将会被解析生成以下的DOM树。

![]( https://bitsofco.de/content/images/2017/01/DOM.png)

幸运的是，HTML可以部分执行显示，也就是说，并不需要等待整个HTML全部加载解析完毕才开始显示页面。但是，其他的资源有可能阻塞页面的渲染，比如CSS，JavaScript等。

## 创建CSSOM树

CSSOM( CSS对象模型)树是对附在DOM结构上的样式的对象表示。它与DOM树的呈现方式相似，只是每个节点都带上样式 ，不论这些样式是明确定义的还是隐式继承的。

在上述的HTML页面中，`style.css`文件代码如下：

```
body { font-size: 18px; }

header { color: plum; }  
h1 { font-size: 28px; }

main { color: firebrick; }  
h2 { font-size: 20px; }

footer { display: none; }  
```
由此会生成以下的CSSOM树。
![](https://bitsofco.de/content/images/2017/01/CSSOM.png)

CSS文件是渲染阻塞资源，即是说该资源需要完全解析完毕才能进入生成渲染树的环节。CSS并不像HTML那样能执行部分并显示，因为CSS具有继承层叠属性， 后面定义的样式会覆盖或者修改前面的样式。如果我们只使用样式表中部分解析好的样式，我们可能会得到错误的页面效果。结论是，我们只能等待CSS完全解析之后，才能进入关键渲染路径的下一个阶段。

需要注意的是，只要CSS文件适用于当前设备的时候，该文件才能造成渲染阻塞。标签`<link rel=”stylesheet”>`接受`media`属性，该属性规定了此处的CSS文件适用于哪种设备。如果我们有个设备属性值为`orientation: landscape`(横向)的样式，当我们竖着浏览页面的时候，这个CSS资源是不会起作用的，也就不会阻塞渲染的过程了。

CSS也会阻塞脚本，因为JavaScript脚本的执行必须等到CSSOM生成之后。

## 执行JavaScript

JavaScript是一种“解析阻塞资源”，也就是说它能阻塞HTML页面的解析。

当页面解析到`<script>`标签，不管脚本是內联的还是外联，页面解析都会暂停，转而加载JavaScript文件(外联的话)并且执行JavaScript脚本。这也是为什么如果JavaScript文件有引用HTML文档中的元素，JavaScript文件必须放在那个元素的后面。

为了避免JavaScript文件阻塞页面的解析，我们可以在`<script>`标签上添加`async`属性，使得JavaScript文件异步加载。

`<script async src="script.js">`

## 生成渲染树

渲染树是DOM和CSSOM的结合，是最终能渲染到页面的元素的树形结构表示。也就是说，它包含能在页面中最终呈现的元素，而不包含那些用CSS样式隐藏的元素，比如带有`display: none;`属性的元素。

所以，上述例子的渲染树如下所示。

![](https://bitsofco.de/content/images/2017/01/Render-Tree.png)
